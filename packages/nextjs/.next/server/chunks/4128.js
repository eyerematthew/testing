"use strict";exports.id=4128,exports.ids=[4128],exports.modules={4308:(e,t,a)=>{a.d(t,{h:()=>c});var r=a(77627),n=a(87871),o=a(94003),i=a(44518),s=a(97464),d=a(77933);async function c(e,t){let{account:a=e.account,chainId:c,nonce:l}=t;if(!a)throw new n.T({docsPath:"/docs/eip7702/prepareAuthorization"});let u=(0,r.J)(a),h=(()=>{if(t.executor)return"self"===t.executor?t.executor:(0,r.J)(t.executor)})(),p={address:t.contractAddress??t.address,chainId:c,nonce:l};return void 0===p.chainId&&(p.chainId=e.chain?.id??await (0,i.T)(e,s.T,"getChainId")({})),void 0===p.nonce&&(p.nonce=await (0,i.T)(e,d.y,"getTransactionCount")({address:u.address,blockTag:"pending"}),("self"===h||h?.address&&(0,o.h)(h.address,u.address))&&(p.nonce+=1)),p}},9371:(e,t,a)=>{a.d(t,{k:()=>d});var r=a(85131),n=a(92485),o=a(95401),i=a(60288),s=a(24841);async function d(e,t){async function a(t){if(t.endsWith(s.vB.slice(2))){let a=(0,n.B)((0,r.iN)(t,-64,-32)),i=(0,r.iN)(t,0,-64).slice(2).match(/.{1,64}/g),d=await Promise.all(i.map(t=>s.BH.slice(2)!==t?e.request({method:"eth_getTransactionReceipt",params:[`0x${t}`]},{dedupe:!0}):void 0)),c=d.some(e=>null===e)?100:d.every(e=>e?.status==="0x1")?200:d.every(e=>e?.status==="0x0")?500:600;return{atomic:!1,chainId:(0,o.ME)(a),receipts:d.filter(Boolean),status:c,version:"2.0.0"}}return e.request({method:"wallet_getCallsStatus",params:[t]})}let{atomic:d=!1,chainId:c,receipts:l,version:u="2.0.0",...h}=await a(t.id),[p,w]=(()=>{let e=h.status;return e>=100&&e<200?["pending",e]:e>=200&&e<300?["success",e]:e>=300&&e<700?["failure",e]:"CONFIRMED"===e?["success",200]:"PENDING"===e?["pending",100]:[void 0,e]})();return{...h,atomic:d,chainId:c?(0,o.ME)(c):void 0,receipts:l?.map(e=>({...e,blockNumber:o.uU(e.blockNumber),gasUsed:o.uU(e.gasUsed),status:i.Lj[e.status]}))??[],statusCode:w,status:p,version:u}}},22868:(e,t,a)=>{a.d(t,{p:()=>i});var r=a(64418),n=a(52968),o=a(49090);function i(e,{docsPath:t,...a}){let i=(()=>{let t=(0,o.l)(e,a);return t instanceof r.RM?e:t})();return new n.$s(i,{docsPath:t,...a})}},24841:(e,t,a)=>{a.d(t,{BH:()=>p,vB:()=>h,yM:()=>w});var r=a(77627),n=a(38295),o=a(54263),i=a(84064),s=a(91149),d=a(95401),c=a(29762),l=a(22868),u=a(59400);let h="0x5792579257925792579257925792579257925792579257925792579257925792",p=(0,c.cK)(0,{size:32});async function w(e,t){let{account:a=e.account,capabilities:w,chain:f=e.chain,experimental_fallback:m,experimental_fallbackDelay:v=32,forceAtomic:g=!1,id:y,version:C="2.0.0"}=t,T=a?(0,r.J)(a):null,b=t.calls.map(e=>{let t=e.abi?(0,i.p)({abi:e.abi,functionName:e.functionName,args:e.args}):e.data;return{data:e.dataSuffix&&t?(0,s.xW)([t,e.dataSuffix]):t,to:e.to,value:e.value?(0,c.cK)(e.value):void 0}});try{let t=await e.request({method:"wallet_sendCalls",params:[{atomicRequired:g,calls:b,capabilities:w,chainId:(0,c.cK)(f.id),from:T?.address,id:y,version:C}]},{retryCount:0});if("string"==typeof t)return{id:t};return t}catch(a){if(m&&("MethodNotFoundRpcError"===a.name||"MethodNotSupportedRpcError"===a.name||"UnknownRpcError"===a.name||a.details.toLowerCase().includes("does not exist / is not available")||a.details.toLowerCase().includes("missing or invalid. request()")||a.details.toLowerCase().includes("did not match any variant of untagged enum")||a.details.toLowerCase().includes("account upgraded to unsupported contract")||a.details.toLowerCase().includes("eip-7702 not supported")||a.details.toLowerCase().includes("unsupported wc_ method")||a.details.toLowerCase().includes("feature toggled misconfigured"))){if(w&&Object.values(w).some(e=>!e.optional)){let e="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new o.L5(new n.C(e,{details:e}))}if(g&&b.length>1){let e="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new o.jz(new n.C(e,{details:e}))}let t=[];for(let a of b){let r=(0,u.v)(e,{account:T,chain:f,data:a.data,to:a.to,value:a.value?(0,d.uU)(a.value):void 0});t.push(r),v>0&&await new Promise(e=>setTimeout(e,v))}let a=await Promise.allSettled(t);if(a.every(e=>"rejected"===e.status))throw a[0].reason;let r=a.map(e=>"fulfilled"===e.status?e.value:p);return{id:(0,s.xW)([...r,(0,c.cK)(f.id,{size:32}),h])}}throw(0,l.p)(a,{...t,account:T,chain:t.chain})}}},59400:(e,t,a)=>{a.d(t,{v:()=>g});var r=a(77627),n=a(87871),o=a(38295),i=a(33856),s=a(99256),d=a(22868),c=a(38307),l=a(16997),u=a(44518),h=a(9841),p=a(23439),w=a(97464),f=a(43501),m=a(12068);let v=new h.A(128);async function g(e,t){let{account:a=e.account,chain:h=e.chain,accessList:g,authorizationList:y,blobs:C,data:T,gas:b,gasPrice:x,maxFeePerBlobGas:E,maxFeePerGas:M,maxPriorityFeePerGas:R,nonce:N,type:I,value:L,...q}=t;if(void 0===a)throw new n.T({docsPath:"/docs/actions/wallet/sendTransaction"});let B=a?(0,r.J)(a):null;try{(0,p.c)(t);let a=await (async()=>t.to?t.to:null!==t.to&&y&&y.length>0?await (0,i.g)({authorization:y[0]}).catch(()=>{throw new o.C("`to` is required. Could not infer from `authorizationList`.")}):void 0)();if(B?.type==="json-rpc"||null===B){let t;null!==h&&(t=await (0,u.T)(e,w.T,"getChainId")({}),(0,s.v)({currentChainId:t,chain:h}));let r=e.chain?.formatters?.transactionRequest?.format,n=(r||l.Bv)({...(0,c.o)(q,{format:r}),accessList:g,authorizationList:y,blobs:C,chainId:t,data:T,from:B?.address,gas:b,gasPrice:x,maxFeePerBlobGas:E,maxFeePerGas:M,maxPriorityFeePerGas:R,nonce:N,to:a,type:I,value:L}),o=v.get(e.uid);try{return await e.request({method:o?"wallet_sendTransaction":"eth_sendTransaction",params:[n]},{retryCount:0})}catch(t){if(!1===o)throw t;if("InvalidInputRpcError"===t.name||"InvalidParamsRpcError"===t.name||"MethodNotFoundRpcError"===t.name||"MethodNotSupportedRpcError"===t.name)return await e.request({method:"wallet_sendTransaction",params:[n]},{retryCount:0}).then(t=>(v.set(e.uid,!0),t)).catch(a=>{if("MethodNotFoundRpcError"===a.name||"MethodNotSupportedRpcError"===a.name)throw v.set(e.uid,!1),t;throw a});throw t}}if(B?.type==="local"){let t=await (0,u.T)(e,f.ft,"prepareTransactionRequest")({account:B,accessList:g,authorizationList:y,blobs:C,chain:h,data:T,gas:b,gasPrice:x,maxFeePerBlobGas:E,maxFeePerGas:M,maxPriorityFeePerGas:R,nonce:N,nonceManager:B.nonceManager,parameters:[...f.MM,"sidecars"],type:I,value:L,...q,to:a}),r=h?.serializers?.transaction,n=await B.signTransaction(t,{serializer:r});return await (0,u.T)(e,m.L,"sendRawTransaction")({serializedTransaction:n})}if(B?.type==="smart")throw new n.Z({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"});throw new n.Z({docsPath:"/docs/actions/wallet/sendTransaction",type:B?.type})}catch(e){if(e instanceof n.Z)throw e;throw(0,d.p)(e,{...t,account:B,chain:t.chain||void 0})}}},97559:(e,t,a)=>{a.d(t,{c:()=>u});var r=a(38295);class n extends r.C{constructor(e){super(`Call bundle failed with status: ${e.statusCode}`,{name:"BundleFailedError"}),Object.defineProperty(this,"result",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.result=e}}var o=a(50264),i=a(40983),s=a(92621),d=a(82360),c=a(74921),l=a(9371);async function u(e,t){let a,{id:r,pollingInterval:u=e.pollingInterval,status:p=({statusCode:e})=>200===e||e>=300,retryCount:w=4,retryDelay:f=({count:e})=>200*~~(1<<e),timeout:m=6e4,throwOnFailure:v=!1}=t,g=(0,c.A)(["waitForCallsStatus",e.uid,r]),{promise:y,resolve:C,reject:T}=(0,s.Y)(),b=(0,o.lB)(g,{resolve:C,reject:T},t=>{let o=(0,i.w)(async()=>{let i=e=>{clearTimeout(a),o(),e(),b()};try{let a=await (0,d.b)(async()=>{let t=await (0,l.k)(e,{id:r});if(v&&"failure"===t.status)throw new n(t);return t},{retryCount:w,delay:f});if(!p(a))return;i(()=>t.resolve(a))}catch(e){i(()=>t.reject(e))}},{interval:u,emitOnBegin:!0});return o});return a=m?setTimeout(()=>{b(),clearTimeout(a),T(new h({id:r}))},m):void 0,await y}class h extends r.C{constructor({id:e}){super(`Timed out while waiting for call bundle with id "${e}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}},99256:(e,t,a)=>{a.d(t,{v:()=>n});var r=a(27161);function n({chain:e,currentChainId:t}){if(!e)throw new r.jF;if(t!==e.id)throw new r.EH({chain:e,currentChainId:t})}}};